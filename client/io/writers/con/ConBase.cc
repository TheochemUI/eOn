/*
** This file is part of eOn.
**
** SPDX-License-Identifier: BSD-3-Clause
**
** Copyright (c) 2010--present, eOn Development Team
** All rights reserved.
**
** Repo:
** https://github.com/TheochemUI/eOn
*/

#include "client/io/writers/con/ConBase.hpp"
#include "client/Element.hpp"
#include "client/io/IOHelpers.hpp"
#include <iostream>

namespace eonc::io {
bool ConBaseWriter::writeBase(const Matter &mat, std::ofstream &fout,
                              bool withVelocity) {
  // TODO(rg) :: These should be lambda applied sometime
  // if (mat.usePeriodicBoundaries) {
  //     mat.applyPeriodicBoundary();
  // }

  // Early return for empty objects
  const size_t numAtoms = mat.numberOfAtoms();
  if (numAtoms == 0) {
    return false;
  }

  // Get unique masses, preserving order
  const auto uniq_masses = getUniqueValues(mat.getMasses());
  const size_t numComponents = uniq_masses.size();

  std::vector<size_t> csidxs =
      calculateComponentStartIndices(mat, numComponents);

  this->writeHeader(mat, fout);
  this->writeAtoms(mat, fout, csidxs, uniq_masses);

  if (withVelocity) {
    this->writeVelocities(mat, fout, csidxs, uniq_masses);
  }

  return true;
}

void ConBaseWriter::writeHeader(const Matter &mat, std::ofstream &fout) {
  // Headers to be written at the beginning of the file
  const std::vector<std::string> preHeader{"Generated by eOn\n", "\n"};
  const std::vector<std::string> postHeader{"\n", "\n"};

  // Write pre-defined headers
  fout << fmt::format("{}", fmt::join(preHeader, ""));

  // Write cell lengths
  Eigen::Vector3d lengths = mat.cell.rowwise().norm();
  fout << fmt::format("{:.6f}\n", fmt::join(lengths, " "));

  // Calculate and write cell angles
  Eigen::Vector3d angles;
  angles(0) = std::acos(mat.cell.row(0).dot(mat.cell.row(1)) /
                        (lengths(0) * lengths(1))) *
              180 / M_PI;
  angles(1) = std::acos(mat.cell.row(0).dot(mat.cell.row(2)) /
                        (lengths(0) * lengths(2))) *
              180 / M_PI;
  angles(2) = std::acos(mat.cell.row(1).dot(mat.cell.row(2)) /
                        (lengths(1) * lengths(2))) *
              180 / M_PI;
  fout << fmt::format("{:.6f}\n", fmt::join(angles, " "));

  // Write post-header
  fout << fmt::format("{}", fmt::join(postHeader, ""));
}

void ConBaseWriter::writeAtoms(const Matter &mat, std::ofstream &fout,
                               const std::vector<size_t> &csidxs,
                               const VectorType &uniq_masses) {
  // Get unique atomic numbers, preserving order
  const auto uqc_atmnrs = getUniqueCounts(mat.getAtomicNrs());
  const size_t numComponents = uniq_masses.size();

  // Write the number of components
  fout << numComponents << "\n";
  // Write the count of atoms for each component
  fout << fmt::format("{}\n", fmt::join(uqc_atmnrs, " "));
  // Write the unique masses of each component
  fout << fmt::format("{:.6f}\n", fmt::join(uniq_masses, " "));

  // Write atomic symbols and coordinates for each component
  for (size_t jdx = 0; jdx < numComponents; ++jdx) {
    fout << mass2atom(uniq_masses[jdx]) << "\n";
    fout << fmt::format("Coordinates of component{:4}\n", jdx + 1);

    for (size_t i = csidxs[jdx]; i < csidxs[jdx + 1]; ++i) {
      fout << fmt::format("{:.6f} {:.6f} {:.6f} {} {}", mat.getPosition(i, 0),
                          mat.getPosition(i, 1), mat.getPosition(i, 2),
                          mat.getFixed(i), i + 1);
      if (jdx < numComponents - 1 || i < csidxs[jdx + 1] - 1) {
        fout << "\n";
      }
    }
  }
}

void ConBaseWriter::writeVelocities(const Matter &mat, std::ofstream &fout,
                                    const std::vector<size_t> &csidxs,
                                    const VectorType &uniq_masses) {
  const size_t numComponents = uniq_masses.size();
  const auto velocities = mat.getVelocities();

  fout << "\n\n";
  // Write velocities for each component
  for (size_t jdx = 0; jdx < numComponents; ++jdx) {
    fout << mass2atom(uniq_masses[jdx]) << "\n";
    fout << fmt::format("Velocities of component{:4}\n", jdx + 1);

    for (size_t i = csidxs[jdx]; i < csidxs[jdx + 1]; ++i) {
      fout << fmt::format("{:.6f} {:.6f} {:.6f} {} {}", velocities(i, 0),
                          velocities(i, 1), velocities(i, 2), mat.getFixed(i),
                          i + 1);
      if (jdx < numComponents - 1 || i < csidxs[jdx + 1] - 1) {
        fout << "\n";
      }
    }
  }
}

std::vector<size_t>
ConBaseWriter::calculateComponentStartIndices(const Matter &mat,
                                              size_t numComponents) {
  std::vector<size_t> csidxs;
  csidxs.reserve(numComponents + 1);
  csidxs.push_back(0);

  const size_t numAtoms = mat.numberOfAtoms();
  // Iterate over atoms, starting from 1, to determine the starting index of
  // each new component
  for (size_t idx = 1; idx < numAtoms; ++idx) {
    if (mat.getAtomicNr(idx) != mat.getAtomicNr(idx - 1)) {
      csidxs.push_back(idx);
    }
  }
  // Add the total number of atoms as the last index to mark the end of the last
  // component
  csidxs.push_back(numAtoms);

  return csidxs;
}

} // namespace eonc::io
